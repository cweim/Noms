---
phase: 05-google-places-integration
plan: 03
type: execute
---

<objective>
Add place details and photo endpoints to complete Google Places integration.

Purpose: Allow mobile client to fetch detailed place information and photos for display in restaurant cards.
Output: GET /api/places/{place_id} and GET /api/places/{place_id}/photo endpoints.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-google-places-integration/DISCOVERY.md

# Prior plans in this phase
@.planning/phases/05-google-places-integration/05-01-SUMMARY.md
@.planning/phases/05-google-places-integration/05-02-SUMMARY.md

# Current implementation
@backend/app/routers/places.py
@backend/app/services/places.py
@backend/app/schemas/places.py

**Tech stack available:**
- FastAPI 0.109.0 with StreamingResponse for photo
- GooglePlacesService with get_place_details(), get_place_photo()
- Pydantic schemas from 05-02

**From 05-01 and 05-02:**
- GooglePlacesService handles API calls and caching
- PlaceResult schema for response
- places router at /api/places
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add place details endpoint</name>
  <files>backend/app/routers/places.py, backend/app/schemas/places.py</files>
  <action>
    1. Add PlaceDetailResponse schema to schemas/places.py:
       - Extends PlaceResult with additional detail fields
       - Add: website (Optional[str])
       - Add: phone_number (Optional[str])
       - Add: hours (Optional[list[str]]) for opening hours text

    2. Add GET /api/places/{place_id} endpoint to places router:

    ```python
    @router.get("/{place_id}", response_model=PlaceDetailResponse)
    async def get_place_details(
        place_id: str,
        user: dict = Depends(get_current_user)
    ):
        """
        Get detailed information about a place.

        place_id can be either:
        - Google Place ID (starts with "ChIJ...")
        - Internal UUID from our cache

        Requires authentication.
        """
        service = get_places_service()

        # Check if it's a Google place_id or internal UUID
        if place_id.startswith("ChIJ"):
            google_place_id = place_id
        else:
            # Look up Google place_id from our cache by internal UUID
            supabase = get_supabase()
            result = supabase.table("places").select("google_place_id").eq("id", place_id).execute()
            if not result.data:
                raise NotFoundError(message="Place not found", detail={"place_id": place_id})
            google_place_id = result.data[0]["google_place_id"]

        # Get details (uses cache if fresh)
        details = service.get_place_details(google_place_id)
        if not details:
            raise NotFoundError(message="Place not found", detail={"google_place_id": google_place_id})

        return PlaceDetailResponse(
            id=details.get("cached_id"),
            google_place_id=details["place_id"],
            name=details["name"],
            address=details.get("formatted_address"),
            location={"lat": details["geometry"]["location"]["lat"], "lng": details["geometry"]["location"]["lng"]} if "geometry" in details else None,
            photo_reference=details.get("photos", [{}])[0].get("photo_reference") if details.get("photos") else None,
            types=details.get("types", []),
            rating=details.get("rating"),
            price_level=details.get("price_level"),
            open_now=details.get("opening_hours", {}).get("open_now"),
            website=details.get("website"),
            phone_number=details.get("formatted_phone_number"),
            hours=details.get("opening_hours", {}).get("weekday_text")
        )
    ```

    Import get_supabase from app.db and NotFoundError from app.errors.
    Handle both Google place_id and internal UUID lookups.
  </action>
  <verify>
    1. PlaceDetailResponse schema exists in schemas/places.py
    2. GET /{place_id} endpoint exists in places router
    3. Server starts without errors: python -c "from app.main import app; print('OK')"
  </verify>
  <done>
    - PlaceDetailResponse schema with website, phone, hours fields
    - GET /api/places/{place_id} endpoint
    - Handles both Google place_id and internal UUID
    - Returns cached data when fresh, fetches from API when stale
  </done>
</task>

<task type="auto">
  <name>Task 2: Add place photo endpoint</name>
  <files>backend/app/routers/places.py, backend/README.md</files>
  <action>
    1. Add GET /api/places/{place_id}/photo endpoint:

    ```python
    from fastapi.responses import StreamingResponse
    import io

    @router.get("/{place_id}/photo")
    async def get_place_photo(
        place_id: str,
        max_width: int = Query(default=400, ge=100, le=1600),
        user: dict = Depends(get_current_user)
    ):
        """
        Get a photo for a place.

        Returns the image directly (not JSON).
        Mobile client can use this URL as image source.

        Requires authentication.
        """
        service = get_places_service()
        supabase = get_supabase()

        # Get photo_reference from cache
        if place_id.startswith("ChIJ"):
            # Look up by Google place_id
            result = supabase.table("places").select("photo_reference").eq("google_place_id", place_id).execute()
        else:
            # Look up by internal UUID
            result = supabase.table("places").select("photo_reference").eq("id", place_id).execute()

        if not result.data or not result.data[0].get("photo_reference"):
            raise NotFoundError(
                message="Photo not found",
                detail={"place_id": place_id, "hint": "Place may not have a photo"}
            )

        photo_reference = result.data[0]["photo_reference"]

        # Fetch photo from Google
        photo_data = service.get_place_photo(photo_reference, max_width=max_width)
        if not photo_data:
            raise NotFoundError(message="Failed to fetch photo")

        # Return image as streaming response
        return StreamingResponse(
            io.BytesIO(photo_data),
            media_type="image/jpeg"
        )
    ```

    2. Update backend/README.md:
       - Add "Google Places Integration" section
       - Document /api/places/search, /api/places/{place_id}, /api/places/{place_id}/photo endpoints
       - Include curl examples
       - Note that all endpoints require authentication
       - Mention caching behavior (7-day freshness)

    Photo endpoint streams image directly - not JSON wrapped.
    Use StreamingResponse with io.BytesIO for binary data.
  </action>
  <verify>
    1. GET /{place_id}/photo endpoint exists
    2. README.md has Google Places section
    3. Server starts without errors: python -c "from app.main import app; print('OK')"
  </verify>
  <done>
    - GET /api/places/{place_id}/photo endpoint
    - Streams image directly as JPEG
    - max_width query parameter for size control
    - README documents all places endpoints
    - Phase 5 complete with full Google Places integration
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] GET /api/places/search returns place results
- [ ] GET /api/places/{place_id} returns place details
- [ ] GET /api/places/{place_id}/photo streams image
- [ ] All endpoints require authentication
- [ ] README documents Places API endpoints
- [ ] Server starts without errors
</verification>

<success_criteria>

- All tasks completed
- Place details endpoint handles Google place_id and internal UUID
- Photo endpoint streams image data
- README documents all endpoints
- Phase 5: Google Places Integration complete
</success_criteria>

<output>
After completion, create `.planning/phases/05-google-places-integration/05-03-SUMMARY.md`:

Include in summary:
- Phase complete note
- All three plans accomplished
- Ready for Phase 6: Mobile App Foundation
</output>
