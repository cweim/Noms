---
phase: 05-google-places-integration
plan: 02
type: execute
---

<objective>
Create places router with search endpoint and Pydantic schemas.

Purpose: Expose Google Places search functionality via REST API endpoint that mobile client can call.
Output: GET /api/places/search endpoint with proper request validation and response formatting.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-google-places-integration/DISCOVERY.md

# Prior plan in this phase
@.planning/phases/05-google-places-integration/05-01-SUMMARY.md

# Existing backend structure
@backend/app/main.py
@backend/app/routers/users.py
@backend/app/services/places.py
@backend/app/errors.py

**Tech stack available:**
- FastAPI 0.109.0 with async support
- Pydantic for data validation
- GooglePlacesService from 05-01

**Established patterns:**
- Router organization: app.include_router(router, prefix="/api/xxx", tags=["xxx"])
- Protected endpoints use Depends(get_current_user)
- Error responses use custom exceptions (ValidationError, NotFoundError, etc.)

**From 05-01:**
- GooglePlacesService with search_places(), get_place_details(), get_place_photo()
- get_places_service() singleton
- Caching to places table implemented
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for places</name>
  <files>backend/app/schemas/__init__.py, backend/app/schemas/places.py</files>
  <action>
    1. Create backend/app/schemas/ directory with __init__.py
    2. Create backend/app/schemas/places.py with Pydantic models:

    ```python
    from pydantic import BaseModel, Field
    from typing import Optional
    from datetime import datetime

    class PlaceLocation(BaseModel):
        lat: float
        lng: float

    class PlacePhoto(BaseModel):
        photo_reference: str
        height: Optional[int] = None
        width: Optional[int] = None

    class PlaceResult(BaseModel):
        """Place data returned from search/details"""
        id: Optional[str] = None  # Internal UUID from cache
        google_place_id: str
        name: str
        address: Optional[str] = None
        location: Optional[PlaceLocation] = None
        photo_reference: Optional[str] = None
        types: list[str] = []
        rating: Optional[float] = None
        price_level: Optional[int] = None
        open_now: Optional[bool] = None

    class PlaceSearchRequest(BaseModel):
        """Query parameters for place search"""
        q: str = Field(..., min_length=1, description="Search query")
        lat: float = Field(..., ge=-90, le=90, description="Latitude")
        lng: float = Field(..., ge=-180, le=180, description="Longitude")
        radius: int = Field(default=1000, ge=100, le=50000, description="Search radius in meters")

    class PlaceSearchResponse(BaseModel):
        """Response from place search"""
        places: list[PlaceResult]
        count: int
    ```

    Use Field() for validation constraints.
    Make optional fields truly optional with None defaults.
  </action>
  <verify>
    1. backend/app/schemas/places.py exists
    2. Schemas import successfully: python -c "from app.schemas.places import PlaceSearchRequest, PlaceSearchResponse; print('OK')"
  </verify>
  <done>
    - Pydantic schemas for PlaceResult, PlaceSearchRequest, PlaceSearchResponse
    - Validation constraints on lat/lng/radius
    - Optional fields for nullable data
  </done>
</task>

<task type="auto">
  <name>Task 2: Create places router with search endpoint</name>
  <files>backend/app/routers/places.py, backend/app/main.py</files>
  <action>
    1. Create backend/app/routers/places.py:

    ```python
    from fastapi import APIRouter, Depends, Query
    from app.services.places import get_places_service
    from app.schemas.places import PlaceResult, PlaceSearchResponse
    from app.auth import get_current_user

    router = APIRouter()

    @router.get("/search", response_model=PlaceSearchResponse)
    async def search_places(
        q: str = Query(..., min_length=1, description="Search query"),
        lat: float = Query(..., ge=-90, le=90),
        lng: float = Query(..., ge=-180, le=180),
        radius: int = Query(default=1000, ge=100, le=50000),
        user: dict = Depends(get_current_user)
    ):
        """
        Search for places near a location.

        Requires authentication.
        Results are cached to reduce API costs.
        """
        service = get_places_service()
        results = service.search_places(
            query=q,
            lat=lat,
            lng=lng,
            radius=radius
        )

        # Map API results to response schema
        places = [
            PlaceResult(
                id=r.get("cached_id"),
                google_place_id=r["place_id"],
                name=r["name"],
                address=r.get("vicinity") or r.get("formatted_address"),
                location={"lat": r["geometry"]["location"]["lat"], "lng": r["geometry"]["location"]["lng"]} if "geometry" in r else None,
                photo_reference=r["photos"][0]["photo_reference"] if r.get("photos") else None,
                types=r.get("types", []),
                rating=r.get("rating"),
                price_level=r.get("price_level"),
                open_now=r.get("opening_hours", {}).get("open_now")
            )
            for r in results
        ]

        return PlaceSearchResponse(places=places, count=len(places))
    ```

    2. Include router in main.py:
       - Add: from app.routers import places
       - Add: app.include_router(places.router, prefix="/api/places", tags=["places"])
       - Remove the commented placeholder for Phase 5

    Search endpoint requires authentication (Depends(get_current_user)).
    Use Query() for parameter validation.
  </action>
  <verify>
    1. backend/app/routers/places.py exists
    2. Router included in main.py: grep "places.router" backend/app/main.py
    3. Server starts without errors: python -c "from app.main import app; print('OK')"
  </verify>
  <done>
    - places.py router with GET /search endpoint
    - Endpoint requires JWT authentication
    - Query parameters validated with constraints
    - Results mapped to PlaceSearchResponse schema
    - Router included in main.py
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] backend/app/schemas/places.py exists with Pydantic models
- [ ] backend/app/routers/places.py exists with search endpoint
- [ ] places router included in main.py
- [ ] Server starts without import errors
- [ ] Endpoint documented in OpenAPI: check /docs
</verification>

<success_criteria>

- All tasks completed
- Pydantic schemas validate request/response data
- GET /api/places/search endpoint created
- Endpoint requires authentication
- No errors introduced, server starts cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-google-places-integration/05-02-SUMMARY.md`
</output>
