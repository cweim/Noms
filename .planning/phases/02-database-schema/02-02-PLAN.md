---
phase: 02-database-schema
plan: 02
type: execute
---

<objective>
Add performance indexes, automated triggers, and Row Level Security to the Noms database.

Purpose: Optimize query performance and establish security foundation for user data isolation.
Output: Fully optimized and secured database schema ready for API integration in Phase 3.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-schema/DISCOVERY.md
@.planning/phases/02-database-schema/02-01-SUMMARY.md
@PRD.md

**Tech stack available:**
- Supabase project with core schema (users, places, lists, saved_places, journal_entries)
- Backend configured with Supabase connection
- Migration system established

**Key decisions from DISCOVERY.md:**
- Performance indexes on foreign keys
- updated_at trigger for users table
- RLS enabled on all tables
- Basic policies for user data isolation

**Security principle:**
Users can only access their own data (saved_places, journal_entries, lists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add performance indexes and updated_at trigger</name>
  <files>backend/supabase/migrations/20260113000002_add_indexes_and_triggers.sql</files>
  <action>
Create backend/supabase/migrations/20260113000002_add_indexes_and_triggers.sql:

```sql
-- Performance indexes and triggers
-- Phase 2: Database Schema (Plan 2)

-- ============================================
-- PERFORMANCE INDEXES
-- ============================================

-- Saved places queries (most common: "show me my saved places")
CREATE INDEX idx_saved_places_user ON saved_places(user_id);
CREATE INDEX idx_saved_places_user_list ON saved_places(user_id, list_id);
CREATE INDEX idx_saved_places_place ON saved_places(place_id);
CREATE INDEX idx_saved_places_list ON saved_places(list_id) WHERE list_id IS NOT NULL;

-- Journal queries (common: "show my journal", "journal for this place")
CREATE INDEX idx_journal_user ON journal_entries(user_id);
CREATE INDEX idx_journal_user_date ON journal_entries(user_id, eaten_at DESC);
CREATE INDEX idx_journal_place ON journal_entries(place_id) WHERE place_id IS NOT NULL;

-- Lists queries
CREATE INDEX idx_lists_user ON lists(user_id);

-- Places lookup by Google ID (when fetching from API)
CREATE INDEX idx_places_google_id ON places(google_place_id);

-- Places cache freshness (when determining if refresh needed)
CREATE INDEX idx_places_last_fetched ON places(last_fetched_at) WHERE last_fetched_at IS NOT NULL;

-- ============================================
-- AUTOMATED TRIGGERS
-- ============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for users table
CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();

-- ============================================
-- COMMENTS FOR DOCUMENTATION
-- ============================================

COMMENT ON INDEX idx_saved_places_user IS 'Fast lookup of user saved places';
COMMENT ON INDEX idx_journal_user_date IS 'Chronological journal queries';
COMMENT ON INDEX idx_places_google_id IS 'Place lookup by Google Place ID';
COMMENT ON FUNCTION update_updated_at IS 'Auto-update updated_at on row modification';
```

**Update backend/README.md:**

Add to Database Setup section:
```markdown
### Performance Optimization

Indexes have been added for common query patterns:
- User's saved places and journal entries
- Place lookups by Google Place ID
- Chronological journal ordering

The `users.updated_at` field is automatically maintained via trigger.
```

This migration should be applied via Supabase Dashboard SQL Editor after the core schema migration.
  </action>
  <verify>cat backend/supabase/migrations/20260113000002_add_indexes_and_triggers.sql shows indexes and trigger, backend/README.md mentions performance optimization</verify>
  <done>Migration file created with 10 indexes covering user queries, triggers for updated_at automation, documentation updated</done>
</task>

<task type="auto">
  <name>Task 2: Enable Row Level Security with user isolation policies</name>
  <files>backend/supabase/migrations/20260113000003_enable_rls.sql</files>
  <action>
Create backend/supabase/migrations/20260113000003_enable_rls.sql:

```sql
-- Row Level Security policies
-- Phase 2: Database Schema (Plan 2)

-- ============================================
-- ENABLE RLS ON ALL TABLES
-- ============================================

ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE places ENABLE ROW LEVEL SECURITY;
ALTER TABLE lists ENABLE ROW LEVEL SECURITY;
ALTER TABLE saved_places ENABLE ROW LEVEL SECURITY;
ALTER TABLE journal_entries ENABLE ROW LEVEL SECURITY;

-- ============================================
-- USERS TABLE POLICIES
-- ============================================

-- Users can read their own profile
CREATE POLICY "Users can read own profile"
  ON users FOR SELECT
  USING (auth.uid() = id);

-- Users can update their own profile
CREATE POLICY "Users can update own profile"
  ON users FOR UPDATE
  USING (auth.uid() = id);

-- Users are created via trigger on auth.users insert (handled by Supabase Auth)
-- No INSERT policy needed here

-- ============================================
-- PLACES TABLE POLICIES
-- ============================================

-- Anyone can read places (they're cached public data from Google)
CREATE POLICY "Anyone can read places"
  ON places FOR SELECT
  TO authenticated
  USING (true);

-- Only service role can insert/update places (API backend does this)
-- No user-facing policy needed

-- ============================================
-- LISTS TABLE POLICIES
-- ============================================

-- Users can read their own lists
CREATE POLICY "Users can read own lists"
  ON lists FOR SELECT
  USING (auth.uid() = user_id);

-- Users can create their own lists
CREATE POLICY "Users can create own lists"
  ON lists FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Users can update their own lists
CREATE POLICY "Users can update own lists"
  ON lists FOR UPDATE
  USING (auth.uid() = user_id);

-- Users can delete their own lists
CREATE POLICY "Users can delete own lists"
  ON lists FOR DELETE
  USING (auth.uid() = user_id);

-- ============================================
-- SAVED PLACES TABLE POLICIES
-- ============================================

-- Users can read their own saved places
CREATE POLICY "Users can read own saves"
  ON saved_places FOR SELECT
  USING (auth.uid() = user_id);

-- Users can save places
CREATE POLICY "Users can save places"
  ON saved_places FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Users can update their own saves (e.g., move to different list)
CREATE POLICY "Users can update own saves"
  ON saved_places FOR UPDATE
  USING (auth.uid() = user_id);

-- Users can delete their own saves
CREATE POLICY "Users can delete own saves"
  ON saved_places FOR DELETE
  USING (auth.uid() = user_id);

-- ============================================
-- JOURNAL ENTRIES TABLE POLICIES
-- ============================================

-- Users can read their own journal entries
CREATE POLICY "Users can read own journal"
  ON journal_entries FOR SELECT
  USING (auth.uid() = user_id);

-- Users can create journal entries
CREATE POLICY "Users can create journal entries"
  ON journal_entries FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Users can update their own journal entries
CREATE POLICY "Users can update own journal"
  ON journal_entries FOR UPDATE
  USING (auth.uid() = user_id);

-- Users can delete their own journal entries
CREATE POLICY "Users can delete own journal"
  ON journal_entries FOR DELETE
  USING (auth.uid() = user_id);

-- ============================================
-- COMMENTS FOR DOCUMENTATION
-- ============================================

COMMENT ON POLICY "Users can read own profile" ON users IS 'User data isolation';
COMMENT ON POLICY "Anyone can read places" ON places IS 'Places are public cached data';
COMMENT ON POLICY "Users can read own journal" ON journal_entries IS 'Journal privacy';
```

**Update backend/README.md:**

Add Security section:
```markdown
## Security

Row Level Security (RLS) is enabled on all tables:

- **users**: Users can only read/update their own profile
- **places**: Authenticated users can read (public cached data from Google)
- **lists**: Users can only manage their own lists
- **saved_places**: Users can only access their own saves
- **journal_entries**: Users can only access their own journal

All queries automatically enforce these policies via Supabase Auth.
```

This migration should be applied last, after core schema and indexes.
  </action>
  <verify>cat backend/supabase/migrations/20260113000003_enable_rls.sql shows RLS enabled and policies for all tables, backend/README.md documents security model</verify>
  <done>RLS enabled on 5 tables, 18 policies created for user data isolation, places table open for authenticated reads, documentation complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Index migration file exists with 10 indexes
- [ ] Trigger migration file includes updated_at automation
- [ ] RLS migration file enables security on all 5 tables
- [ ] Policies enforce user data isolation
- [ ] backend/README.md documents performance and security
- [ ] All migrations ready to apply via Supabase Dashboard
</verification>

<success_criteria>

- All tasks completed
- Performance indexes cover common query patterns
- Automated triggers reduce manual timestamp management
- RLS enforces user data isolation
- Documentation explains security model
- Phase 2 complete: Database schema fully established
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema/02-02-SUMMARY.md`:

# Phase 2 Plan 2: Database Optimization Summary

**Added performance indexes, automated triggers, and Row Level Security policies**

## Accomplishments

- Created 10 performance indexes for common query patterns
- Implemented automated updated_at trigger for users table
- Enabled Row Level Security on all 5 tables
- Created 18 RLS policies for user data isolation
- Documented performance optimizations and security model

## Files Created/Modified

- `backend/supabase/migrations/20260113000002_add_indexes_and_triggers.sql` - Performance optimization
- `backend/supabase/migrations/20260113000003_enable_rls.sql` - Security policies
- `backend/README.md` - Added Performance Optimization and Security sections

## Decisions Made

- Indexed foreign keys and date fields for common queries (saved places by user, journal chronologically)
- Partial indexes for conditional queries (places cache freshness, non-null list_id)
- Automated updated_at via trigger (no manual management needed)
- Places table open to authenticated users (public cached Google data)
- All user-generated content restricted to owner (lists, saves, journal)
- Service role bypasses RLS for backend operations (place caching)

## Issues Encountered

None

## Next Phase Readiness

Phase 2 complete. Database schema fully established with:
- ✅ Core tables (users, places, lists, saved_places, journal_entries)
- ✅ Performance indexes
- ✅ Automated triggers
- ✅ Row Level Security

**Ready for Phase 3: Backend API Foundation**

Blockers: None

Concerns: RLS policies are basic - Phase 4 (Authentication) will expand with more granular access control if needed
</output>
