---
phase: 04-authentication
plan: 1
type: execute
---

<objective>
Integrate Supabase Auth JWT validation with FastAPI to enable protected endpoints.

Purpose: Establish authentication foundation for user-specific operations (journal entries, saved places, lists). Backend validates user JWTs issued by Supabase Auth; actual signup/login will be handled client-side in Phase 6.
Output: FastAPI backend with JWT validation dependency, user profile trigger, and example protected endpoint.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-authentication/DISCOVERY.md

# Prior phase context
@.planning/phases/03-backend-api-foundation/03-01-SUMMARY.md
@.planning/phases/03-backend-api-foundation/03-02-SUMMARY.md

# Existing backend structure
@backend/app/main.py
@backend/app/db.py
@backend/app/errors.py
@backend/requirements.txt

# Database schema
@backend/supabase/migrations/20260113000001_create_core_schema.sql

**Tech stack available:**
- FastAPI 0.109.0 with async support
- Supabase Python client (supabase==2.3.0)
- Pydantic for data validation
- Custom exception handlers (DatabaseError, AuthenticationError, etc.)
- Error response format established

**Established patterns:**
- Singleton Supabase client with SERVICE_KEY (backend/app/db.py)
- Router organization by feature (/api/auth, /api/places, /api/users)
- Centralized error handling with custom exceptions
- Startup event for database initialization

**Constraining decisions:**
- Phase 2: Users table references auth.users(id) with CASCADE delete
- Phase 3: SERVICE_KEY used for backend admin operations (bypasses RLS)
- Discovery: Client-side auth with Supabase JS SDK, backend only validates JWTs
- Discovery: PyJWT library for HS256 validation, audience="authenticated"

**From DISCOVERY.md:**
- Supabase Auth manages authentication in auth.users table
- Backend does NOT implement signup/login endpoints (client-side only)
- JWT validation uses HS256 algorithm with SUPABASE_JWT_SECRET
- User context extracted from JWT 'sub' claim (user UUID)
- Database trigger needed to auto-create profile in public.users on signup
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JWT validation dependency</name>
  <files>backend/requirements.txt, backend/app/auth.py, backend/.env.example</files>
  <action>
    1. Add PyJWT==2.8.0 to requirements.txt
    2. Create backend/app/auth.py with HTTPBearer security scheme and get_current_user dependency
    3. JWT validation config: HS256 algorithm, audience="authenticated", using SUPABASE_JWT_SECRET
    4. Return JWT payload dict with claims (sub, email, role, etc.)
    5. Raise AuthenticationError for expired/invalid tokens with specific error messages:
       - jwt.ExpiredSignatureError → "Token has expired"
       - jwt.InvalidAudienceError → "Invalid token audience"
       - jwt.InvalidTokenError → "Invalid authentication token"
    6. Add SUPABASE_JWT_SECRET to .env.example with comment explaining where to get it

    Use exact code structure from DISCOVERY.md Code Examples section (lines 643-718).
    Do NOT implement signup/login endpoints - those are client-side only.
    Do NOT use python-jose - stick with PyJWT for simplicity.
  </action>
  <verify>
    1. PyJWT appears in requirements.txt
    2. backend/app/auth.py imports successfully: python -c "from app.auth import get_current_user; print('OK')"
    3. .env.example contains SUPABASE_JWT_SECRET entry
  </verify>
  <done>
    - PyJWT added to dependencies
    - auth.py with get_current_user dependency created
    - HTTPBearer security scheme configured
    - JWT validation with HS256, audience="authenticated"
    - AuthenticationError raised for invalid/expired tokens
    - Environment variable template updated
  </done>
</task>

<task type="auto">
  <name>Task 2: Add database trigger for user profile creation</name>
  <files>backend/supabase/migrations/20260114000001_add_user_trigger.sql</files>
  <action>
    Create SQL migration that auto-creates a record in public.users when a user signs up via Supabase Auth.

    1. Create migration file: backend/supabase/migrations/20260114000001_add_user_trigger.sql
    2. Add function handle_new_user() that inserts into public.users with NEW.id, NOW() timestamps
    3. Use SECURITY DEFINER so trigger has permission to insert
    4. Create trigger on_auth_user_created: AFTER INSERT ON auth.users FOR EACH ROW
    5. Add comments explaining the trigger purpose

    This trigger ensures every auth.users signup automatically creates a profile in public.users.
    Without this, users would authenticate but have no profile record.

    Use exact SQL structure from DISCOVERY.md lines 221-234.
  </action>
  <verify>
    1. Migration file exists at backend/supabase/migrations/20260114000001_add_user_trigger.sql
    2. SQL is valid (no syntax errors): grep -E "CREATE (FUNCTION|TRIGGER)" backend/supabase/migrations/20260114000001_add_user_trigger.sql
    3. README documents this migration
  </verify>
  <done>
    - Migration file created with handle_new_user() function
    - Trigger on_auth_user_created added to auth.users table
    - Function uses SECURITY DEFINER for permissions
    - Comments explain auto-profile creation
    - README.md updated with migration instructions
  </done>
</task>

<task type="auto">
  <name>Task 3: Create protected endpoint example and router</name>
  <files>backend/app/routers/users.py, backend/app/main.py, backend/README.md</files>
  <action>
    Create users router with a protected endpoint that demonstrates JWT authentication.

    1. Create backend/app/routers/users.py with APIRouter
    2. Add GET /api/users/me endpoint:
       - Uses get_current_user dependency from app.auth
       - Extracts user_id from user["sub"] claim
       - Queries public.users table for profile (single().execute())
       - Returns user_id, email (from JWT), created_at, updated_at (from database)
       - Handle case where profile doesn't exist (should be created by trigger)
    3. Include router in main.py: app.include_router(users.router, prefix="/api/users", tags=["users"])
    4. Update backend/README.md:
       - Add "Authentication" section explaining JWT validation
       - Document /api/users/me endpoint usage with curl example
       - Explain Authorization: Bearer <token> header requirement
       - Note that signup/login are client-side operations

    Use code structure from DISCOVERY.md lines 722-771.
    Do NOT query database with SERVICE_KEY without user_id filter - always scope to authenticated user.
  </action>
  <verify>
    1. app/routers/users.py exists and imports successfully
    2. Router included in main.py: grep "users.router" backend/app/main.py
    3. Server starts without errors: python -c "from app.main import app; print('OK')"
    4. README.md documents authentication section
  </verify>
  <done>
    - users.py router created with GET /api/users/me endpoint
    - Endpoint requires JWT authentication via get_current_user dependency
    - User profile queried from database using JWT sub claim
    - Router included in main.py with /api/users prefix
    - README.md documents authentication flow and example usage
    - Protected endpoints pattern established for future use
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] PyJWT installed: pip list | grep PyJWT
- [ ] backend/app/auth.py imports without errors
- [ ] Migration file exists with trigger SQL
- [ ] Users router created and included in main.py
- [ ] Server starts successfully: python -m app.main (Ctrl+C after startup)
- [ ] No import errors or startup failures
</verification>

<success_criteria>

- All tasks completed
- JWT validation dependency created and functional
- Database trigger migration file ready to apply
- Protected endpoint example demonstrates auth pattern
- README documents authentication setup
- No errors introduced, server starts cleanly
  </success_criteria>

<output>
After completion, create `.planning/phases/04-authentication/04-01-SUMMARY.md`:

---
phase: "4"
plan_number: "1"
plan_name: "JWT Validation and User Profile Trigger"
started: "YYYY-MM-DD"
completed: "YYYY-MM-DD"
subsystem: "backend-auth"
key_files:
  - backend/app/auth.py
  - backend/app/routers/users.py
  - backend/supabase/migrations/20260114000001_add_user_trigger.sql
tech_stack:
  added:
    - "PyJWT 2.8.0 (JWT validation)"
  patterns:
    - "HTTPBearer dependency injection for protected routes"
    - "JWT validation with audience claim verification"
    - "Database trigger for auto-profile creation"
key_decisions:
  - "Client-side auth pattern: Supabase JS SDK handles signup/login, FastAPI validates JWTs"
  - "PyJWT over python-jose for simplicity (HS256 validation)"
  - "Manual user_id filtering with SERVICE_KEY client (RLS enforcement deferred)"
---

# Phase 4 Plan 1: JWT Validation and User Profile Trigger - Summary

**Backend authentication foundation established with JWT validation and auto-profile creation**

## Accomplishments

- Created JWT validation dependency (get_current_user) for protecting endpoints
- Added database trigger to auto-create user profiles on signup
- Implemented example protected endpoint (/api/users/me)
- Documented authentication flow and usage in README

## Files Created/Modified

- `backend/requirements.txt` - Added PyJWT==2.8.0
- `backend/app/auth.py` - JWT validation dependency with HTTPBearer
- `backend/app/routers/users.py` - Users router with /me endpoint
- `backend/app/main.py` - Included users router
- `backend/supabase/migrations/20260114000001_add_user_trigger.sql` - Auto-profile creation trigger
- `backend/.env.example` - Added SUPABASE_JWT_SECRET
- `backend/README.md` - Authentication section

## Decisions Made

- Client-side authentication pattern (Supabase JS SDK for signup/login, backend validates only)
- PyJWT library for HS256 JWT validation (simpler than python-jose)
- Audience claim verification ("authenticated") to ensure user tokens
- Manual user_id filtering for now (RLS enforcement with user-scoped client deferred to future)

## Issues Encountered

[Document any issues, or "None"]

## Next Phase Readiness

**Phase 5 (Google Places Integration):** Can proceed - no dependencies on frontend auth implementation.

**Phase 6 (Mobile App Foundation):** Will need to implement Supabase Auth client-side (signup/login UI) and store/send JWTs with API requests.

**Testing:** Trigger needs to be applied to Supabase and tested with actual signup flow (manual testing or Phase 6).
</output>
